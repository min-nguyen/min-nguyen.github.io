\documentclass[acmsmall, 9pt]{article}

\usepackage[a4paper, total={6in, 10in}]{geometry}
\input{../tex/packages}
\input{../tex/layout-tweaks}
\input{../tex/macros}
\input{../tex/listings}

\setlist[itemize]{leftmargin=4mm}
\setlist[enumerate]{leftmargin=4mm}
\addbibresource{../bibliography.bib}
\begin{document}
\pagestyle{empty}

\title{Higher-Order Polymorphic Typed Lambda Calculus: Approaches to Formalising Grammars}

\maketitle
\noindent
System F$_\omega$ \cite{cambridge-lambda-calc, pierce2002types}, also known as higher-order polymorphic lambda calculus, extends System F with richer kinds $K$, namely the kind $K_1 \rightarrow K_2$ of type constructors, and adds type-level lambda-abstraction $\lambda \alpha^K. \, A$ and application $A\,B$.

\begin{align*}
  \text{Kinds} \quad K &::= * \; | \; K_1 \rightarrow K_2\\
  \text{Types} \quad  A, B &::= \iota \; | \;  A \rightarrow B \; | \; \forall \alpha^K . \, A\; | \; \alpha \; | \; \lambda \alpha^K. \, A \; | \; A \, B
\end{align*}

We are also free to extend the set of kinds $K$ with other arbitrary kind constants, which means our set of types we range over with $A, B$ includes non-value types of kind other than $*$. We must therefore consider various details when organizing the type calculus, such as what syntactic classes of type metavariables are there, what are the kinding rules for our types, which kinds of types can be polymorphic over, and what kinds of types can we use in type application. There are a number of options in how to formalize a grammar with rich kinds.

Let's consider adding row types $R$ to our grammar, which is an unordered collection of labels $\ell$. We say that rows have kind $\mathsf{Row}$ and labels have kind $\mathsf{Label}$. From rows, we can then form variants (sums) $\tyAngle{R}$ and records (products) $\tyBrace{R}$ which are value types of kind $*$.

\subsubsection{Type Indiscriminative Method}
\label{sssec:tau-method}
The most general way is to use a single type metavariable $T$ which captures all types of different kinds $K$. We note that this relies on the kinding rules to delineate which types are well-formed. For example:
\begin{align*}
  &\text{Kinds} \quad &K &::= * \; | \; K_1 \rightarrow K_2 \; | \; \mathsf{Row} \; | \; \mathsf{Label} \span\span \\
  &\text{Types} \quad &T &::= c \; | \; \tyFun{T_1}{T_2} \; | \; \forall \alpha^K . \, T\; | \; \alpha \; | \; \lambda \alpha^K. \, T \;| \; T_1 \; T_2 \;    \span\span\\
  &&&| \quad  l \; | \; l ; T \; | \; \cdot \; | \;\tyBrace{T} \; | \; \tyAngle{T} \\
\end{align*}
Here we have type constants $c$ which capture value types such as $\texttt{Bool}$. Functions are written $\tyFun{T_1}{T_2}$. Universal quantification $\forall \alpha^K. \, T$ can quantify over types of any kind $K$ to produce some type $T$ of kind $K'$. Type variables $\alpha$ can be inhabited by types of any kind which $T$ ranges over. Type abstraction $\lambda \alpha^K. \, T$ has higher-kind $K_1 \rightarrow K_2$. Type application $T_1 \, T_2$ can then allow types of kinds other than $*$ and $* \rightarrow *$ to be applied to each other. We then have labels $l$, rows extended with labels $l; T$, empty rows $\cdot$, records $\tyBrace{T}$, and variants $\tyAngle{T}$.

% but for this to be well-formed under the kinding rules, $T_1$, $T_2$ and $T_1 \rightarrow T_2$ must be of kind $*$.
This grammar therefore permits functions, type application, type abstraction, and universal quantification to work over types of any kind. We note that this grammar on its own cannot dictate what types are well-formed or ill-formed, therefore it is important to have kinding rules to express what is allowed. For example, this type syntax says that a function $l \rightarrow l$ between two types of kind $\mathsf{Label}$ is possible, however this isn't well-formed as we cannot pass or return labels as values.


\begin{figure}[H]
\flushleft \shadebox{$\Delta \vdash T : K$}
\begin{smathpar}
   \inferrule*[lab={\ruleName{constant}}]
   {
   }
   {
      \Delta \vdash c : *
   }
   \and
  \inferrule*[lab={\ruleName{function}}]
  {
     \Delta \vdash T_1 : *
     \\
     \Delta \vdash T_2 : *
  }
  {
     \Delta \vdash \tyFun{T_1}{T_2} : *
  }
  \and
  \inferrule*[lab={\ruleName{forall}}]
  {
     \Delta \concat (\alpha : K) \vdash T : *
  }
  {
     \Delta \vdash \forall \alpha^K. \, T : *
  }
  \and
  \inferrule*[lab={\ruleName{type variable}}]
  {
     \alpha : K \in \Delta
  }
  {
     \Delta \vdash \alpha : K
  }
  \and
  \inferrule*[lab={\ruleName{type constructor}}]
  {
     \Delta \concat (\alpha : K_1) \vdash T : K_2
  }
  {
     \Delta \vdash \lambda \alpha^{K_1} . \, T : \tyFun{K_1}{K_2}
  }
  \and
  \inferrule*[lab={\ruleName{type constructor application}}]
  {
     \Delta \vdash T_1 : \tyFun{K_1}{K_2}
     \\
     \Delta \vdash T_2 : K_1
  }
  {
     \Delta \vdash T_1 \, T_2 : K_2
  }
  \and
  \inferrule*[lab={\ruleName{label}}]
  {
  }
  {
     \Delta \vdash l  : \mathsf{Label}
  }
  \and
  \inferrule*[lab={\ruleName{row-extend}}]
  {
     \Delta \vdash l : \mathsf{Label}
     \\
     \Delta \vdash T : \mathsf{Row}
  }
  {
     \Delta \vdash l; T  : \mathsf{Row}
  }
  \and
  \inferrule*[lab={\ruleName{row-empty}}]
  {
  }
  {
     \Delta \vdash \cdot  : \mathsf{Row}
  }
  \and
  \inferrule*[lab={\ruleName{record}}]
  {
     \Delta \vdash T : \mathsf{Row}
  }
  {
     \Delta \vdash \tyBrace{T} : *
  }
  \and
  \inferrule*[lab={\ruleName{variant}}]
  {
     \Delta \vdash T : \mathsf{Row}
  }
  {
     \Delta \vdash \tyAngle{T} : *
  }
\end{smathpar}
\caption{Kinding Rules}
\end{figure}


\subsubsection{Type Categorization Method}
\label{sssec:type-categorization-method}
Another method is to distinguish between type metavariables which produce types of different kinds. For example:
\begin{align*}
&\text{Kinds} \quad &K &::= * \; | \; K_1 \rightarrow K_2 \; | \; \mathsf{Row} \; | \; \mathsf{Label}\\
&\text{Value Types} \quad  &A, B &::= c \; | \; A \rightarrow B \; | \; \forall \alpha^K . \, A\; | \; \alpha \; | \; \lambda \alpha^K. \, A \; | \; A \, B \; | \; \{ R \} \; | \; \tyAngle{R}\\
&\text{Row Types} \quad &R &::= l; R \; | \; \cdot \; | \; \rho \\
&\text{Label Types} \quad &l &::= l_1 \; | \; l_2 \; | \; \ldots
\end{align*}
\textbf{Value types} $A,B$ are any types which produce a kind $*$, except for type variables $\alpha$. This includes type constants $c$ and functions $A \rightarrow B$. Universally quantified types, $\forall \alpha^K . \; A$, are able to quantify over types with any kind $K$ in $\forall \alpha^K. \, A$ but the type variable $\alpha^K$ must always be used to return a type $A$ of kind $*$. We also consider type constructors $\lambda \alpha^K. \; A$ of kind $K_1 \rightarrow K_2$ as value types, which take as input a type of rich kind $K_1$ but must eventually produce a type of kind $*$ in $K_2$. Type application $A\;B$ applies a type constructor $A$ to a value type $B$. Lastly, record types $\langle R \rangle$, functions $A \rightarrow B$, universally quantified types $\forall \alpha^K . \; A$, and type application $A\;B$, which are all of kind $*$.

Note that although we can abstract over types of kind $K$ in type constructors $\lambda \alpha^K. \, A$, type constructor application $A\,B$ does not allow us to apply type constructors to types of kind other than $*$; this means types such as record constructors $\{ \, \_ \, \}$ cannot exist on their own, only records $\{ R \}$ which are already applied to a row type $R$ to yield a kind $*$.

\lbreak
\textbf{Non-value} types are types which produce kinds other than $*$. This includes row types $R$ and label types $l$. We note that row types $R$ also have their own row type variable $\rho$, which allows $\rho$ to be used in place of where $R$ can occur, and hence row types can be defined polymorphically. The fact that universal quantification is only defined in value types $A, B$ means that row types must be used in the context of a value type where $\rho$ is quantified over by $\forall \alpha^\mathsf{Row} . \; A$ where we can unify $\rho$ and $\alpha$.

\lbreak
This approach more clearly delineates type of different kinds, and restricts type application, type abstraction, and universal quantification to types which produce a kind $*$. This is desirable whenever we want to enforce a stronger well-formed type system within the grammar itself, e.g. that values can only possibly have types $A, B$ with output kinds $*$ at the term-level, and that types which use type constructors to take a richly-kinded type as input must already be fully applied to have a kind $*$. A disadvantage of this is that type constructor application $A\,B$ does not allow us to apply type constructors to types of kind other than $*$.

If we instead wanted type constructors to be applied to types of any kind $K$, and allow universal quantification and type abstraction to produce types of rich kinds e.g. $\mathsf{Row}$ to be produced and exist on their own, we would need to change some things to make the calculus closer to the design of the type indiscriminative system (in \ref{sssec:tau-method}):
\begin{enumerate}
  \item The cleanest way would be to introduce a metavariable $T$ which ranges types of all kinds, and add universal quantification, type abstraction, and type application to $T$. Types which can be defined polymorphically still need their own type variables included in their grammar, e.g. value types have type variable $\alpha$ which unifies with $\forall \alpha^K.\, T$ when $K = *$, and row types have type variable  $\rho$ which unifies with $\forall \alpha^K.\, T$ when $K = \mathsf{Row}$.
  \begin{align*}
   &\text{Kinds} \quad &K &::= * \; | \; K_1 \rightarrow K_2 \; | \; \mathsf{Row} \; | \; \mathsf{Label}\\
   &\text{Types} \quad &T &::= A \; | \; R \; | \; L \; | \; \forall \alpha^K . \, T\; | \; \lambda \alpha^K. \, T \; | \; T_1 \, T_2\\
   &\text{Value Types} \quad  &A, B &::= c \; | \; A \rightarrow B \;  | \; \alpha \; |  \; \{ R \} \\
   &\text{Type Constants} \quad &c &::= \texttt{bool} \; | \; \texttt{int}\\
   &\text{Row Types} \quad &R &::= \llparenthesis \; \rrparenthesis \; | \; \llparenthesis \; L \; | \; R \rrparenthesis \; | \; \rho \\
   &\text{Label Types} \quad &L &::= l_1 \; | \; l_2 \; | \; \ldots
  \end{align*}
  When doing this however, we need to be careful about considering the subtype/supertype relation between $T$ and more specific types $A, R, L$. A consequence of placing type forms $ \forall \alpha^K . \, T, \; \lambda \alpha^K. \, T$, and $T_1 \, T_2$ under $T$ is that we can no longer use these in place of value types $A, B$, because $T$ does not occur anywhere else except within its own syntactic category. This means that the type forms such as $\alpha$ and $\tyFun{A}{B}$ which $A, B$ can expand out, are more restricted in what they can expand out into. For example, although we can express $\forall \alpha^K. \, (\tyFun{A}{B})$ (by expanding out $\forall \alpha^K. \, T$), it is not possible to represent $\tyFun{(\forall \alpha^K. \, A)}{(\forall \alpha^K. \, B)}$ unless we add a form $\tyFun{T_1}{T_2}$ as a member of the metavariable $T$.
  \item Another way would be to introduce the constructs of type variables, universal quantification, and type abstraction for each different kind. However this is very verbose, and we also have to capture type application for all possible kinds we can apply a type abstraction to:
  \begin{align*}
  &\text{Kinds} \quad &K &::= * \; | \; K_1 \rightarrow K_2 \; | \; \mathsf{Row} \; | \; \mathsf{Label}\\
  &\text{Value Types} \quad  &A, B &::= c \; | \; A \rightarrow B \; | \; \forall \alpha^K . \, A\; | \; \alpha \; | \; \lambda \alpha^K. \, A \; | \; A \, B \; | \; \{\,R\,\} \; | A \, R\\
  &\text{Type Constants} \quad &c &::= \texttt{bool} \; | \; \texttt{int}\\
  &\text{Row Types} \quad &R &::= \llparenthesis \; \rrparenthesis \; | \; \llparenthesis \; L \; | \; R \rrparenthesis \; | \; \rho \; | \; \forall \alpha^K . \, R \; | \; \lambda \alpha^K. \, R \; | \; R \, L \; | \; R \, R\\
  &\text{Label Types} \quad &L &::= l_1 \; | \; l_2 \; | \; \ldots
  \end{align*}
  Note that we can now specify universal quantification and type abstraction over row types as well as value types. Record constructors can be applied to row types using type application $A\,R$, for example, where $A := \lambda\alpha^\mathsf{Row}.\,\{\,\alpha\}$ and $R := \llparenthesis \, \rrparenthesis$. Row types can also be applied to labels and other rows using $R\,L$ and $R\,R$, for example, we can apply a row to a label by letting $R := \lambda \alpha^\mathsf{Label}. \, \llparenthesis \, \alpha \, | \, \llparenthesis \, \rrparenthesis \, \rrparenthesis$ and $L ::= l_1$.
\end{enumerate}

\subsubsection{\textbullet \; Explicitly Kinded Type Indiscriminative Method \cite{leijen2005extensible}}
When we have a system with rich kinds, we can refine the notion of using a single metavariable $T$ to capture non-value types of kinds other than $*$ (as described in \ref{sssec:tau-method}) by assigning \textit{kinds} $K$ to the type metavariable $T$ as $T^K$ to exclude ill-formed types.

For each kind $K$ we have a collection of types $T^K$; this includes type constants $c^K$, polymorphic types $\forall \alpha^K . \, T^{K'}$, type variables $\alpha^K$, and type application $T_1^{K_2 \rightarrow K} \; T_2^{K_2}$. (including function arrows, and type constructors)

\begin{align*}
  &\text{Kinds} \quad &K &::= * \; | \; K_1 \rightarrow K_2 \; | \; \mathsf{Row} \; | \; \mathsf{Label} \\
  &\text{Types} \quad &T^K &::= c^K \; | \; \forall \alpha^{K_1} . \, T^{K_2}\; | \; \alpha^K \; | \; \lambda \alpha^{K_1}. \, T^{K_2} \; |  \; T_1^{K_2 \rightarrow K} \; T_2^{K_2} \span\span\\
  &\text{Type constants} \quad &c^K &::= \texttt{()}, \texttt{bool}, \texttt{int} &::& \; *\\
  &&&| \quad (\rightarrow) &::& \; * \rightarrow * \rightarrow * \\
  &&&| \quad \texttt{Maybe} &::& \; * \rightarrow *
\end{align*}

\noindent
This provides a safer way to specify a grammar for types which can range over multiple kinds including richer kinds. For example using a \textit{row polymorphic calculus} where we have a kind $\mathsf{Row}$:
\begin{enumerate}[leftmargin=4mm]
  \item One way of specifying a calculus is to use the \textit{type categorization method} (\ref{sssec:type-categorization-method}) and explicitly distinguish the metavariables which range over types for different kinds. Here, $A, B$ range over regular types and $R$ ranges over row types. Similarly, $\alpha$ ranges over regular type variables and $\rho$ ranges over row type variables, but when universally quantifying over a bound type variable, we can let $\alpha^K$ represent either.
  \begin{align*}
    \text{Kinds} \quad K &::= * \; | \; K_1 \rightarrow K_2 \; | \; \mathsf{Row}\\
    \text{Regular Types} \quad  A, B &::= \iota \; | \; A \rightarrow B \; | \; \forall \alpha^K. \, A\; | \; \alpha \; | \; \lambda \alpha^K . \, A \; | \; A \, B\\
    \text{Row Types} \quad R &::= \ell \; ; R \; | \; \cdot \; | \; \rho
  \end{align*}
  \item Another way is to use the \textit{type indiscriminative method} (\ref{sssec:tau-method}) to let $T$ range over types of all kinds in our language, and $\alpha$ can be used as a type variable in place of these kinds.
  \begin{align*}
    \text{Kinds} \quad k &::= * \; | \; k_1 \rightarrow k_2 \; | \; \mathsf{Row}\\
    \text{Types} \quad T &::=  \iota \; | \; T_1 \rightarrow T_2 \; | \; \forall \alpha^k. \, T\; | \; \alpha \; | \; \lambda \alpha^K. \, T \; | \;T_1 \, T_2 \; | \; \ell \; ; T \; | \; \cdot
  \end{align*}
  \item Now, we can assign kinds to types in the \textit{type indiscriminative method} to exclude ill-formed types. We let the metavariable for types be parameterised by a kind, and hence range over types of all kinds.
  \begin{align*}
    \text{Kinds} \quad k &::= * \; | \; k_1 \rightarrow k_2 \; | \; \mathsf{Row}\\
    \text{Types} \quad T^k &::= \iota \; | \; T^{k_1}_1 \rightarrow T^{k_2}_2 \;  | \; \forall \alpha^{k_0}. \, T^{k}\; | \; \alpha^k \; | \; \lambda \alpha^{k_0}. \, T^{k_1} \; | \; T^{k_2 \rightarrow k}_1 \, T^{k_2}_2 \; | \; \ell \; ; T^{\mathsf{Row}} \; | \; \cdot
  \end{align*}
  We can then let a choice of metavariables range over types over different kinds, e.g. let $\epsilon \doteq T^{\mathsf{Row}}$, and similarly with type variables, e.g. let $\varepsilon \doteq \alpha^{\mathsf{Row}}$.
\end{enumerate}

\printbibliography
\end{document}